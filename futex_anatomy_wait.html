<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Jak Boulton | Anatomy of the Futex: Wait & Notify</title>
        <link rel="icon" type="image/x-icon" href="assets/pull-request.svg"/>
        <link rel="stylesheet" href="assets/styles.css">
    </head>
    <body class="terminal">
        <div class="container">
            <div class="title-bar">
                <span><a href="/">&#10531; Home</a></span>
                <img src="assets/pull-request.svg" class="window-icon">
            </div>
            <header>
                <h1>Anatomy of the Futex: Wait & Notify</h1>
                <time datetime="2025-07-19" class="date">19th July 2025</time>
                <span class="reading-time">8 minute read</span>
           </header>
           <main>
                <p>Once upon a time I was investigating the reason for the existance of the Futex and why developers looking for a fast, low latency lock often reach for this primitive. Unfortunately for this past version of myself; resources on the topic and details of the implementation were scarce. These details can certinly be found, but I'm yet to find a single resource that covers most of what you need to know in a single place. If - like that previous version of me - you are looking for details on what a Futex is and how it is implemented; you have come to the right place!</p>
<hr />
<h2>What is a Futex?</h2>
<p>Let us begin by quoting a snippet from the <a href="https://en.wikipedia.org/wiki/Futex" target="_blank" rel="noopener noreferrer">Futex Wikipedia page</a>:</p>
<blockquote>
<p>In computing, a futex (short for &quot;fast userspace mutex&quot;) is a kernel system call that programmers can use to implement basic locking, or as a building block for higher-level locking abstractions such as semaphores and POSIX mutexes or condition variables.</p>
</blockquote>
<p>While this snippet is somewhat misleading, it does give us a step in the right direction. Futex is short for <em>&quot;fast userspace mutex&quot;</em>, it <em>is</em> a Mutex that is <em>fast</em> and in <em>userspace</em>. We all know what is meant by the term fast, but what does userspace mean in this context?</p>
<p>Userspace is referring to any code that is <em>not</em> executed within the operating system kernel. There is a cost to transitioning our execution context into and out of the kernel (along with not knowing when the execution context will be returned), generally leading to increased latency. The goal then, is to remain in userspace as much as possible - this is what makes a Futex <em>fast</em>.</p>
<h2>Mutex Breakdown</h2>
<p>Now that we know what a Futex is, lets take a look at how we can split a Mutex into its constituent parts to review how it could be optimised for low latency. All modern desktop operating systems provide a range of kernel level synchronisation primitives, including a Mutex:</p>
<ul>
<li>Windows; <a href="https://learn.microsoft.com/en-us/windows/win32/sync/using-mutex-objects" target="_blank" rel="noopener noreferrer">Using Mutex Objects</a></li>
<li>Linux; <a href="https://linux.die.net/man/3/pthread_mutex_lock" target="_blank" rel="noopener noreferrer">Man Page: pthread_mutex_lock</a></li>
<li>Mac; <a href="https://developer.apple.com/documentation/synchronization/mutex" target="_blank" rel="noopener noreferrer">Developer Documentation: Mutex</a></li>
</ul>
<p>The consistent issue shared by these primitives is that using them forces us into kernel space when acquiring or releasing the lock and so we will have to pay the associated performance and latency cost. What can we do to resolve this?</p>
<p>Reviewing the behaviour of a Mutex; what parts are needed for the implementation? First, we need some state to determine if a lock is currently in use - and it <em>must</em> be atomic due to multithreaded requirement:</p>
<pre style="background-color:#fdf6e3;">
<span style="color:#cb4b16;">#include </span><span style="color:#839496;">&lt;</span><span style="color:#2aa198;">atomic</span><span style="color:#839496;">&gt;
</span><span style="color:#657b83;">
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">futex </span><span style="color:#657b83;">{
</span><span style="color:#657b83;">    std::atomic_bool _is_locked;
</span><span style="color:#657b83;">};
</span></pre>
<p>We then need a <code>lock</code> or <code>acquire</code> method to exclusively acquire the lock and an <code>unlock</code> or <code>release</code> method to give other threads access to the lock:</p>
<pre style="background-color:#fdf6e3;">
<span style="color:#cb4b16;">#include </span><span style="color:#839496;">&lt;</span><span style="color:#2aa198;">atomic</span><span style="color:#839496;">&gt;
</span><span style="color:#657b83;">
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">futex </span><span style="color:#657b83;">{
</span><span style="color:#657b83;">    std::atomic_bool _is_locked;
</span><span style="color:#657b83;">
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span style="color:#657b83;">    </span><span style="color:#b58900;">futex</span><span style="color:#657b83;">() = </span><span style="color:#859900;">default</span><span style="color:#657b83;">;
</span><span style="color:#657b83;">
</span><span style="color:#657b83;">    </span><span style="color:#93a1a1;">// other constructors ...
</span><span style="color:#657b83;">
</span><span style="color:#657b83;">    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">lock</span><span style="color:#657b83;">() {
</span><span style="color:#657b83;">        </span><span style="color:#859900;">while </span><span style="color:#657b83;">(</span><span style="color:#b58900;">true</span><span style="color:#657b83;">) {
</span><span style="color:#657b83;">            </span><span style="color:#268bd2;">bool</span><span style="color:#657b83;"> expected = </span><span style="color:#b58900;">false</span><span style="color:#657b83;">;
</span><span style="color:#657b83;">            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(_is_locked.</span><span style="color:#b58900;">compare_exchange_weak</span><span style="color:#657b83;">(
</span><span style="color:#657b83;">                    expected, </span><span style="color:#b58900;">true</span><span style="color:#657b83;">,
</span><span style="color:#657b83;">                    std::memory_order_acquire,
</span><span style="color:#657b83;">                    std::memory_order_relaxed)) {
</span><span style="color:#657b83;">                </span><span style="color:#859900;">break</span><span style="color:#657b83;">;
</span><span style="color:#657b83;">            }
</span><span style="color:#657b83;">        }
</span><span style="color:#657b83;">    }
</span><span style="color:#657b83;">
</span><span style="color:#657b83;">    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">unlock</span><span style="color:#657b83;">() {
</span><span style="color:#657b83;">        _is_locked.</span><span style="color:#b58900;">store</span><span style="color:#657b83;">(</span><span style="color:#b58900;">false</span><span style="color:#657b83;">, std::memory_order_release);
</span><span style="color:#657b83;">    }
</span><span style="color:#657b83;">};
</span></pre>
<p>This implementation is <em>technically</em> already complete, assuming there is no misuse (like recursively calling lock or calling release when the lock isn't held). This is also incredibly fast when used in low contention scenarios due locking and unlocking requiring a single atomic operation.</p>
<p>The problem is that all threads waiting for the lock will spin-loop until the lock is available - not good. The other tool we need is a way to sleep the thread while it waits for the lock, and wake it up when the lock is available.</p>
<h2>Atomic Wait &amp; Notify</h2>
<p>One option would be to use the operating system primitives listed above to sleep the threads; but we can do better! All desktop operating systems also provide a low-cost primitive for sleeping and waking threads:</p>
<ul>
<li>Windows: <a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress" target="_blank" rel="noopener noreferrer">WaitOnAddress</a> &amp; <a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-wakebyaddresssingle" target="_blank" rel="noopener noreferrer">WakeByAddress</a></li>
<li>Linux: <a href="https://linux.die.net/man/7/futex" target="_blank" rel="noopener noreferrer">futex</a></li>
<li>Mac: <a href="https://developer.apple.com/documentation/os/os_sync_wait_on_address" target="_blank" rel="noopener noreferrer">os_sync_wait_on_address</a> &amp; <a href="https://developer.apple.com/documentation/os/os_sync_wake_by_address_any" target="_blank" rel="noopener noreferrer">os_sync_wake_by_address</a></li>
</ul>
<p>Interestingly, this has been a problem area on Mac for some time due to syscalls being a violation of Apple's store guidelines. The Mac APIs linked above were introduced with XCode 15.4, released in May 2024.</p>
<p>The title of this section is &quot;Atomic Wait &amp; Notify&quot; because in C++20, these low cost sleep / wake primitives were added to the standard as building blocks intended for use with primitives like the Futex. Wait on address maps to atomic wait and wake by address maps to atomic notify. The APIs being referenced can be found on <em>cppreference</em>:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/atomic/atomic_wait.html" target="_blank" rel="noopener noreferrer">std::atomic_wait</a></li>
<li><a href="https://en.cppreference.com/w/cpp/atomic/atomic_notify_one.html" target="_blank" rel="noopener noreferrer">std::atomic_notify</a></li>
</ul>
<p>You may have noticed that the dates don't quite match up. These APIs were introduced in C++20, but Apple only added <em>usable</em> support for them in 2024. This does mean that another primitive was used to appoximate the behaviour on Mac, meaning it isn't possible to write a Futex with the lowest possible latency on Mac if we're using only the C++ standard library. We will also have to wait for a version of MacOS that supports these APIs to reach relative ubiquity before releasing software that uses them on Mac - luckily Apple are rather pushy with OS updates.</p>
<h2>Putting it all together</h2>
<p>Now that we have all of the tools required to implement a Futex, lets take a look at a complete draft implementation:</p>
<pre style="background-color:#fdf6e3;">
<span style="color:#cb4b16;">#include </span><span style="color:#839496;">&lt;</span><span style="color:#2aa198;">atomic</span><span style="color:#839496;">&gt;
</span><span style="color:#657b83;">
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">futex </span><span style="color:#657b83;">{
</span><span style="color:#657b83;">    </span><span style="color:#859900;">constexpr static uint8_t</span><span style="color:#657b83;"> status_unlocked = </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">;
</span><span style="color:#657b83;">    </span><span style="color:#859900;">constexpr static uint8_t</span><span style="color:#657b83;"> status_locked = </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">;
</span><span style="color:#657b83;">    </span><span style="color:#859900;">constexpr static uint8_t</span><span style="color:#657b83;"> status_contended = </span><span style="color:#6c71c4;">2</span><span style="color:#657b83;">;
</span><span style="color:#657b83;">
</span><span style="color:#657b83;">    std::atomic&lt;</span><span style="color:#859900;">uint8_t</span><span style="color:#657b83;">&gt; _status;
</span><span style="color:#657b83;">
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span style="color:#657b83;">    </span><span style="color:#b58900;">futex</span><span style="color:#657b83;">() = </span><span style="color:#859900;">default</span><span style="color:#657b83;">;
</span><span style="color:#657b83;">
</span><span style="color:#657b83;">    </span><span style="color:#93a1a1;">// other constructors ...
</span><span style="color:#657b83;">
</span><span style="color:#657b83;">    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">lock</span><span style="color:#657b83;">() {
</span><span style="color:#657b83;">        </span><span style="color:#859900;">uint8_t</span><span style="color:#657b83;"> expected = status_unlocked;
</span><span style="color:#657b83;">        </span><span style="color:#859900;">if </span><span style="color:#657b83;">(_status.</span><span style="color:#b58900;">compare_exchange_strong</span><span style="color:#657b83;">(expected, status_locked,
</span><span style="color:#657b83;">                std::memory_order_acquire, std::memory_order_relaxed)) {
</span><span style="color:#657b83;">            </span><span style="color:#859900;">return</span><span style="color:#657b83;">;
</span><span style="color:#657b83;">        }
</span><span style="color:#657b83;">
</span><span style="color:#657b83;">        </span><span style="color:#859900;">while </span><span style="color:#657b83;">(</span><span style="color:#b58900;">true</span><span style="color:#657b83;">) {
</span><span style="color:#657b83;">            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(expected != status_contended) {
</span><span style="color:#657b83;">                </span><span style="color:#859900;">const uint8_t</span><span style="color:#657b83;"> desired = expected + </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">;
</span><span style="color:#657b83;">                </span><span style="color:#859900;">if </span><span style="color:#657b83;">(_status.</span><span style="color:#b58900;">compare_exchange_weak</span><span style="color:#657b83;">(expected, desired,
</span><span style="color:#657b83;">                        std::memory_order_acquire, std::memory_order_relaxed)) {
</span><span style="color:#657b83;">                    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(desired == status_locked) {
</span><span style="color:#657b83;">                        </span><span style="color:#859900;">return</span><span style="color:#657b83;">;
</span><span style="color:#657b83;">                    }
</span><span style="color:#657b83;">                }
</span><span style="color:#657b83;">            }
</span><span style="color:#657b83;">
</span><span style="color:#657b83;">            _status.</span><span style="color:#b58900;">wait</span><span style="color:#657b83;">(status_contended, std::memory_order_acquire);
</span><span style="color:#657b83;">            expected = _status.</span><span style="color:#b58900;">load</span><span style="color:#657b83;">(std::memory_order_relaxed);
</span><span style="color:#657b83;">        }
</span><span style="color:#657b83;">    }
</span><span style="color:#657b83;">
</span><span style="color:#657b83;">    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">unlock</span><span style="color:#657b83;">() {
</span><span style="color:#657b83;">        </span><span style="color:#859900;">if </span><span style="color:#657b83;">(_status.</span><span style="color:#b58900;">exchange</span><span style="color:#657b83;">(status_unlocked,
</span><span style="color:#657b83;">                std::memory_order_release) == status_contended) {
</span><span style="color:#657b83;">            _status.</span><span style="color:#b58900;">notify_one</span><span style="color:#657b83;">();
</span><span style="color:#657b83;">        }
</span><span style="color:#657b83;">    }
</span><span style="color:#657b83;">};
</span></pre>
<p>The main changes to our previous code is as follows:</p>
<ul>
<li>Our state now consists of 3 options <em>unlocked</em>, <em>locked</em> &amp; <em>contended</em>; this is used to determine if a thread is waiting for the lock or not</li>
<li>The atomic wait and notify have been added to the implemention using the <code>std::atomic&lt;T&gt;</code> wrappers</li>
<li>We've added an explicit <em>fast path</em> and <em>slow path</em> to the <code>lock</code> method</li>
</ul>
<p>The first thread to acquire the lock will succeed at the compare exchange strong (fast path) and early exit; in low contention scenarios acquiring the lock will be incredibly fast. If there is contention however, a single thread will succeed quickly while the others will fall into the while loop (slow path). These other threads will use atomic wait to await changes to the <code>_status</code> field.</p>
<p>Once the first thread has completed its critical section, it will call <code>unlock</code> which will atomically <code>exchange</code> the state. <code>exchange</code> returns the previous value of the atomic, this is checked for if it is <em>contended</em> and if so atomic <code>notify</code> will be called to wake up a single waiting thread. The idea here is that if the state is <em>locked</em>, there is no threads waiting and therefore the notify call is not required - significantly reducing the cost of locking and unlocking if there is no contention.</p>
<p>As a final note; we <em>must</em> assume that threads waiting could wake up without unlock being called, this is known as a &quot;spurious wake up&quot;. We have protected against this by trapping execution in a loop and restricting the exit conditions carefully.</p>
<h2>What is next?</h2>
<p>I do not claim for this to be a production ready implementation, there are many areas that could be improved, including the already mentioned protection against recursive locking and multiple unlocking. On top of these, there are also a number of additions that could be made to increase performance further, such as a limited low-power spin looping to attempt to <em>catch</em> cases where the lock is held for a very short period.</p>
<p>The Rust standard library implementation is open source and easy to read and understand, if you would like to review something production ready: <a href="https://doc.rust-lang.org/nightly/src/std/sys/sync/mutex/futex.rs.html" target="_blank" rel="noopener noreferrer">futex.rs</a></p>

                <div class="navigation">
    <span class="top-text">
        <a href="#top">&#10532; Back To Top</a>
    </span>
    <span class="flavour-text">
        Gdt Sun, 20 Jul 2025 01:25:58 +0100&nbsp;&nbsp;&nbsp;&nbsp;
        Spaces: 4&nbsp;&nbsp;&nbsp;&nbsp;
        UTF-8&nbsp;&nbsp;&nbsp;&nbsp;
        LF&nbsp;&nbsp;&nbsp;&nbsp;
        HTML&nbsp;&nbsp;&nbsp;&nbsp;&#10064;
    </span>
</div>
           </main>
       </div>
    </body>
</html>
